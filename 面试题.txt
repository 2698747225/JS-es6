sessionStorage 
浏览器中同源窗体下有效，无法设置保存时间，关闭浏览器失效

localStorage
浏览器中长期保存，可以设置保存时间。大小和sessionStorage相似，比cookie大了不少，5M以上容量

cookie
服务器端同样有session和cookie的存取机制，相对最大容量为4M，每次服务请求会默认带入cookie信息，因此比较适合做自动登录。相对而言安全性较低，也就只能存点自动登录的东西了。
乐车邦的店铺切换信息也是存在cookie里，目前还有点问题，因为可以设置path和domain地址，这边domain的截取方式错误，不能兼容两个后缀的地址。gg

display:none和visibility:hidden的区别
第一个隐藏不占位，第二个占位

link和@import的区别
link是浏览器标签，在页面加载时会加载，@import是CSS元素，在页面加载后加载。link无兼容性问题

可继承的样式：font-size，font-family，color

absolute：生成绝对定位元素，相对于static（ 默认定位）以外的第一个祖先元素定位
fixed：相对于窗口定位
relative：相对定位元素，相对于在文档流中的位置进行定位
static：默认定位（忽略top、bottom、left、right、z-index）
inherit：继承父元素的position

语义化优点
1、若CSS样式没有加载，还可以使页面呈现出基本的结构
2、方便爬虫获取关键信息，爬虫一般依赖标签确定信息的权重
3、方便代码维护，减少差异化

doctype
告知浏览器以何种模式渲染文档（严格模式、混杂模式）
当docType不存在或格式不正确，文档将以混杂模式呈现

IE8以下版本的浏览器中盒模型不包括内边距和边框

JS中未声明的变量都将作为全局变量（默认window.）

iframe的优点是并行加载，可以把第三方图标、广告的内容放在iframe中
缺点是即使没有内容，加载iframe也需要时间，并且消耗内存

关于无样式闪烁
无样式闪烁是指 <style type="text/css" media="all">@import "../fouc.css";</style> ，@import会加载的Css比较慢，页面会有一定时间的真空期，
改为head中添加link或script直接加载css能解决

null和undefined的区别
null指的是一个已经申明却为"空值"的"对象"(typeof为object)
undefined指申明的对象，未赋值
简单来讲就是undefined表示一个未预料到的空，例如出错或者一个void类型的函数返回，并非正常情况的空，相反null表示一个可预期的空对象

优雅降级和渐进增强
优雅降级：web页面在完成后支持最新的浏览器。针对与老的浏览器，做一些兼容处理或者添加候选方案，使在旧式浏览器上体验不完全失效
渐进增强：一开始设计底层就以支持全部浏览器版本为主，完成最基础的功能。在之后的修改中针对不同浏览器的兼容性添加适当的功能

box-sizing
content-box（默认）、padding-box（作废）、border-box
content-box内容宽高即为样式的宽高，padding、border在宽高之外，换句话说就是宽度会大于width已定的宽度
border-box怪异模型，padding、border会和内容共同分享width或height的宽高。

http1.0和1.1区别
1、支持长连接connection:keep-alive，并且在一次tcp连接中可以发送多个请求（节省的资源主要是在tcp连接的建立方面，但新的请求任然要等待之前请求的响应）
2、host域，支持虚拟机共享同一个IP地址，发送不同的主机名
3、请求优化。会提前发送option请求（只有请求头），若返回403表示拒绝请求，否则再发送正式带有body体的请求，节约带宽
4、新增了多个request方法（put、delete、options...）和响应码

http2.0和http1.1的区别
1、http2.0的请求解析是基于二进制，http1.1是基于文本（文本表现形式比较多，会导致需要做很多兼容处理）
2、http2.0支持多路复用（比较与http1.1多个请求可以并发请求，不会阻塞）
3、请求头header的缓存。通讯双方会缓存header请求头字典，差量更新头信息，避免每次发送都带入全部的头信息，并且http2.0请求会压缩header

throttle函数实现
function throttle(fnc,wait){
	let previous = 0;
	return function(){
		if(+new Date()-previous>wait){
			fnc();
			previous = +new Date();
		}
	}
}
和debounce相似用来处理频繁事件触发导致的性能损失。
每次触发事件时，判断和上次事件触发的事件差，若小于规定时间，则不触发，否则触发事件，并重新记录触发时间。保证每一次时间触发的频率>=规定频率

纯css实现自适应
暂时通过vm、vh来实现（视窗大小而非父节点），通俗易懂

inherit函数实现
辅助函数的用途是返回一个继承当前对象方法的子类对象，主要通过的方法是修改父类函数的protoType的指向，指向需要被继承对象，
inherit(proto=new Object()){
	const F = ()=>{};
	// 核心步骤
	F.protoType=proto;
	return new F();
}

蹦床函数实现
主要解决递归导致的调用栈庞大问题
function trampoline(f){
	while(f&&typeof f === 'function'){
		f = f();
	}
	return f;
}

css sprites
多张图片通过background-position等操作整合成一张图片，提高加载效率。有现有的整合工具。使用sprites同时可以优化http请求，把多张图片整合成一张大图，请求只会获取一张图片

document.write页面流写入，会覆盖整个页面

http和https差别
http运行在tcp协议上，通过三次握手建立连接
https运行在SSL/TLS上,以加密形式传输

position:sticky
粘性定位。在元素还在屏幕范围内时，定位不会受影响。屏幕范围外时会类似fixed定位方式。
sticky定位元素不会脱离文档流。
sticky定位浏览器兼容性较差

document.onload和window.ready的区别
document.onload事件会在dom完全加载、渲染结束后才会执行，而window.ready事件是在页面dom树加载完后执行，不需要等待图片的加载，所以ready事件
会在onload事件执行之前执行。一般会把图片的加载回调放在onload事件中执行。

tcp连接复用
传统http连接，客户端发送http请求，经过三次握手建立tcp连接，等响应结束后，客户端会发送FIN ACK数据包，服务器和客户端断开连接。每次请求都会重新建立tcp连接，比较耗费资源
TCP连接复用技术会通过把多个客户端的http请求复用到后端与服务器建立的一个TCP连接上。
客户端会先和负载均衡设备建立tcp连接，负载均衡设备收到请求后，会查看服务器是否有空闲连接，若没有则新建连接，把客户端的request请求发往服务器。负载均衡设备在收到客户端发
送的FIN ACK包后，断开与客户端的连接，但不断开与服务器之间的连接，等待下一个客户端的请求。在接受到下一个请求后，直接发往与服务器之间空闲的连接，节约服务器资源消耗。

http复用
就是header中connection字段为keep-alive，保持tcp链接不断开，每次发送请求都需要等待上个请求结束后，才会在同一个
tcp连接中发送多个http请求。

transform和top、left偏移差异
transform有rotate（旋转）,scale（按比例放大）,skew（按轴旋转，会导致元素扭曲）,translate（按某个轴位移）
top等会使cpu计算其他元素的shadow等样式，渲染效率会降低。使用translate会启动硬件加速，通过GPU对样式计算，渲染效率更高

内联元素和块级元素差别
内联元素一般为a、label等文字类、img图片类，这类内联元素宽高、边距等都不受css控制，而根据内容来控制
块级元素一般为列表类型 P、table、h、ul、div等，高度由内部控制，宽度100%
内联块元素，同行显示并且可修改宽高、边距等

引入CSS的三种方式
1、通过style标签中直接写css类
2、link type=type/css 引入css文件
3、css文件内@import（会出现样式闪烁）

tcp和UDP区别
一、tcp采用三次握手连接，UDP不用请求连接。
二、tcp连接需要消耗更多的资源。tcp连接有确认、重传、拥塞机制，可以保证数据无差别的传送，UDP没有以上机制，为了确保数据最快的传输。（tcp保证不丢包）
三、tcp连接只能一对一，UDP可以多对多

 什么时候应该使用TCP： 
当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、
SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、
SSH QQ文件传输 ………… 
什么时候应该使用UDP：
 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

跨域问题解决
一、get方式通过jsonp的格式传输数据
二、模拟iframe，通过window.postMessage和eventListener('message')传递数据
三、跨域资源共享。后端设置Access-Control-Allow-Origin允许
四、nginx反向代理配置
五、wabpack配置代理proxy的changeOrigin属性模拟转发服务器请求

https基于SSL通信原理
一、客户端发送https请求至服务器
二、服务器返回证书和公有密钥
三、客户端接收到证书后，使用根证书对服务器发来的证书进行验证，如果证书不可信则访问中断
四、客户端随机生成一段对称密钥，并用服务器发送的公有密钥进行加密，发送给服务器端
五、服务器端接收到对称密钥后，通过私有密钥对对称密钥进行解密
六、这样就可以通过对称密钥进行加密通信了

闭包
闭包可以延长作用域和可以保存延长作用域的变量。
正常情况下，一个函数执行完之后，其内部的变量都会被垃圾回收调，但内部的闭包函数可以保存函数的变量值。因此闭包也可以用来返回函数内部的参数。

事件绑定和普通事件的区别
普通事件是在dom元素上添加onclick事件等，事件绑定是添加eventListener添加监听。普通事件相同事件只允许绑定一个，事件绑定可以绑定多个。

JS本地对象、内置对象、宿主对象
本地对象指JS自带的对象，可以全局通过new实例化的对象，例如String，Array，Date，File，Blob等
内置对象指不需要实例化的对象，例如Math、String、
宿主对象指浏览器提供的对象，例如window，document

前端的性能优化主要针对几点
尽量减少http请求
	图片加载方面优化：
		由于每张图片都会占用一次请求，因此可以通过sprites整合多张图片到一张大图，这样就可以只用一次http请求获得。
		部分静态图片分离出来，通过background-image方式获得不需要调用请求。
	通过http2的请求多路复用的特性可以防止请求阻塞，导致页面渲染慢。
	webpack、gulp等打包工具可以压缩整个项目的JS文件到一个大的JS文件。
	可以利用浏览器缓存减少请求次数（if-none-match和if-modify-since）
	JS文件放在body末尾防止由于执行JS文件过长时间的阻塞请求、css放在header中保证第一时间加载图片，提高页面展现效果。

预处理机制
JS执行分在编译、执行阶段，编译阶段会对声明的函数和变量进行内存分配，这时声明类型的函数会进行变量提升，有个类似的面试题
var fn = 1;
function fn(){console.log('this is function');}
fn() //报错，提示fn不是函数类型

尾调用优化
由于在函数执行最后一步（返回），当前函数的调用帧会注销，因此把内部执行函数放在最后一部执行，就可以在内部函数调用时，外部函数调用帧就已注销，节约内存。（特别适用于递归函数）

JS原生继承
JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，
这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函
数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用多的继承模式是组合继承，这种模式使
用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 

此外，还存在下列可供选择的继承模式。
一、原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 
二、寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强 对象，后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导
致的低效率问 题，可以将这个模式与组合继承一起使用。
三、寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的有效方式。（寄生式继承不使用子类原型指向父类实例，因为子类构造函数中已经执行过一次父类构造，并绑定
实例属性，因此只需要把父类的原型替换子类的原型即可）
 
私有变量
私有变量为函数内声明的变量，可以通过闭包的方式延长函数作用域链让外部访问
静态私有变量和普通的函数私有变量差别在于实例化次数。静态私有变量为自执行函数表达式，只执行一次，因此所有实例共享静态私有变量（是通过构造函数原型方法闭包返回私有变量，
原型方法由于继承关系，所有实例共享，这样所有实例都会共享同一个闭包返回的私有变量）
函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表 达式也叫做匿名函数。 
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； 
递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名――函数名可 能会发生变化。 
当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理 如下。  
	在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
  	通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 
	但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
使用闭包可以在 JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下。  
	创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。结果就是函数内部的所有变量都会被立即销毁――除非将某些变量赋
	值给了包含作用域（即外 部作用域）中的变量。
 闭包还可以用于在对象中创建私有变量，相关概念和要点如下。  
	即使 JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公 有方法可以访问在包含作用域中定义的变量。 
	有权访问私有变量的公有方法叫做特权方法。  
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强 的模块模式来实现单例的特权方法。 JavaScript 中的函数表达式和闭包都是极其有用的特性，
利用它们可以实现很多功能。不过，因为 创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。

判断基础类型
通过instanceof 实际上是 obj instanceof Constructor 实现，判断的是 obj.__proto_===Function.prototype的方式
通过Function.toString方法打印类型。 Object.prototype.toString.apply(value).slice(8,-1)；

html rem、em
em指相对于父元素的字体大小
rem一般是相对于全局的，一般针对移动端会有(clientWidth/750*100)为html上的font-size，而占有一半则是指50rem

title和h1、b和strong、i和em
title权重比h1高，更容易被搜索引擎检索，h1用来概括文章主题，因此希望标题容易被搜索引擎检索则使用title，若为显示文章标题可用h1
strong标签起的作用是强调内容，而b标签是单纯的bold意思，只为了设置加粗样式
i和em差别在于i标签是斜体、em标签是强调文本的作用，表现方面虽然相同，但em标签更容易被搜索引擎检索

typeof和instanceof区别
两个方法一般都用来验证类型
typeof用来判断一个变量类型，能够判断的有(7个):number,string,object,boolean,undefined,function,symbol，对于数组、对象、null、window等内置对象都会返回object
instanceof主要对继承关系做检测，判断逻辑是左是否为右的实例，以下是成立的
var obj = {};
var a =function(){};
obj.__proto__ = a.prototype;
obj instanceof a // true
因此可以判断验证的是左侧对象的原型是否指向右侧原型

事件循环
JS是单线程，主线程会先执行所有同步事件，当遇到异步事件时会将异步事件教给异步进程处理，在异步任务完毕后，会推入任务队列中，当主线程（同步事件执行）完成后，会
去任务队列中取一个任务，推入主线程执行，当这个任务执行完后，又会去任务队列中取一个任务，以此类推。这就是一个事件循环过程。而异步任务中又会区分为microtask和macrotask
promise是microtask evet，因此setTimeout正常都是在promise之后执行。
宏任务执行完后，在下一个宏任务执行前，浏览器可以进行渲染。而微任务是在宏任务执行后，页面渲染前立即执行的任务，而script也被包含在宏任务中，也就是说在script执行完后，页面没
渲染前就会执行所有微任务（这个过程中新加的微任务会被放到队列尾部）。

import的任务是只读的，不能进行修改，只有export之后才能修改